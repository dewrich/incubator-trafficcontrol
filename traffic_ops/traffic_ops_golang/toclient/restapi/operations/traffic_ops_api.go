// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"net/http"
	"strings"

	errors "github.com/go-openapi/errors"
	loads "github.com/go-openapi/loads"
	runtime "github.com/go-openapi/runtime"
	middleware "github.com/go-openapi/runtime/middleware"
	security "github.com/go-openapi/runtime/security"
	spec "github.com/go-openapi/spec"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/apache/incubator-trafficcontrol.tor-api/traffic_ops/traffic_ops_golang/toclient/restapi/operations/asn"
	"github.com/apache/incubator-trafficcontrol.tor-api/traffic_ops/traffic_ops_golang/toclient/restapi/operations/cdn"
	"github.com/apache/incubator-trafficcontrol.tor-api/traffic_ops/traffic_ops_golang/toclient/restapi/operations/division"
	"github.com/apache/incubator-trafficcontrol.tor-api/traffic_ops/traffic_ops_golang/toclient/restapi/operations/region"
	"github.com/apache/incubator-trafficcontrol.tor-api/traffic_ops/traffic_ops_golang/toclient/restapi/operations/status"
)

// NewTrafficOpsAPI creates a new TrafficOps instance
func NewTrafficOpsAPI(spec *loads.Document) *TrafficOpsAPI {
	return &TrafficOpsAPI{
		handlers:            make(map[string]map[string]http.Handler),
		formats:             strfmt.Default,
		defaultConsumes:     "application/json",
		defaultProduces:     "application/json",
		ServerShutdown:      func() {},
		spec:                spec,
		ServeError:          errors.ServeError,
		BasicAuthenticator:  security.BasicAuth,
		APIKeyAuthenticator: security.APIKeyAuth,
		BearerAuthenticator: security.BearerAuth,
		JSONConsumer:        runtime.JSONConsumer(),
		JSONProducer:        runtime.JSONProducer(),
		AsnDeleteASNHandler: asn.DeleteASNHandlerFunc(func(params asn.DeleteASNParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation AsnDeleteASN has not yet been implemented")
		}),
		CdnDeleteCDNHandler: cdn.DeleteCDNHandlerFunc(func(params cdn.DeleteCDNParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation CdnDeleteCDN has not yet been implemented")
		}),
		DivisionDeleteDivisionHandler: division.DeleteDivisionHandlerFunc(func(params division.DeleteDivisionParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation DivisionDeleteDivision has not yet been implemented")
		}),
		RegionDeleteRegionHandler: region.DeleteRegionHandlerFunc(func(params region.DeleteRegionParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation RegionDeleteRegion has not yet been implemented")
		}),
		StatusDeleteStatusHandler: status.DeleteStatusHandlerFunc(func(params status.DeleteStatusParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation StatusDeleteStatus has not yet been implemented")
		}),
		AsnGetASNByIDHandler: asn.GetASNByIDHandlerFunc(func(params asn.GetASNByIDParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation AsnGetASNByID has not yet been implemented")
		}),
		AsnGetASNsHandler: asn.GetASNsHandlerFunc(func(params asn.GetASNsParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation AsnGetASNs has not yet been implemented")
		}),
		CdnGetCDNByIDHandler: cdn.GetCDNByIDHandlerFunc(func(params cdn.GetCDNByIDParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation CdnGetCDNByID has not yet been implemented")
		}),
		CdnGetCDNsHandler: cdn.GetCDNsHandlerFunc(func(params cdn.GetCDNsParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation CdnGetCDNs has not yet been implemented")
		}),
		DivisionGetDivisionByIDHandler: division.GetDivisionByIDHandlerFunc(func(params division.GetDivisionByIDParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation DivisionGetDivisionByID has not yet been implemented")
		}),
		DivisionGetDivisionsHandler: division.GetDivisionsHandlerFunc(func(params division.GetDivisionsParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation DivisionGetDivisions has not yet been implemented")
		}),
		RegionGetRegionByIDHandler: region.GetRegionByIDHandlerFunc(func(params region.GetRegionByIDParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation RegionGetRegionByID has not yet been implemented")
		}),
		RegionGetRegionsHandler: region.GetRegionsHandlerFunc(func(params region.GetRegionsParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation RegionGetRegions has not yet been implemented")
		}),
		StatusGetStatusByIDHandler: status.GetStatusByIDHandlerFunc(func(params status.GetStatusByIDParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation StatusGetStatusByID has not yet been implemented")
		}),
		StatusGetStatusesHandler: status.GetStatusesHandlerFunc(func(params status.GetStatusesParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation StatusGetStatuses has not yet been implemented")
		}),
		AsnPostASNHandler: asn.PostASNHandlerFunc(func(params asn.PostASNParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation AsnPostASN has not yet been implemented")
		}),
		CdnPostCDNHandler: cdn.PostCDNHandlerFunc(func(params cdn.PostCDNParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation CdnPostCDN has not yet been implemented")
		}),
		DivisionPostDivisionHandler: division.PostDivisionHandlerFunc(func(params division.PostDivisionParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation DivisionPostDivision has not yet been implemented")
		}),
		RegionPostRegionHandler: region.PostRegionHandlerFunc(func(params region.PostRegionParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation RegionPostRegion has not yet been implemented")
		}),
		StatusPostStatusHandler: status.PostStatusHandlerFunc(func(params status.PostStatusParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation StatusPostStatus has not yet been implemented")
		}),
		AsnPutASNHandler: asn.PutASNHandlerFunc(func(params asn.PutASNParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation AsnPutASN has not yet been implemented")
		}),
		CdnPutCDNHandler: cdn.PutCDNHandlerFunc(func(params cdn.PutCDNParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation CdnPutCDN has not yet been implemented")
		}),
		DivisionPutDivisionHandler: division.PutDivisionHandlerFunc(func(params division.PutDivisionParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation DivisionPutDivision has not yet been implemented")
		}),
		RegionPutRegionHandler: region.PutRegionHandlerFunc(func(params region.PutRegionParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation RegionPutRegion has not yet been implemented")
		}),
		StatusPutStatusHandler: status.PutStatusHandlerFunc(func(params status.PutStatusParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation StatusPutStatus has not yet been implemented")
		}),

		// Applies when the "cookie" header is set
		CookieAuth: func(token string) (interface{}, error) {
			return nil, errors.NotImplemented("api key auth (Cookie) cookie from header param [cookie] has not yet been implemented")
		},

		// default authorizer is authorized meaning no requests are blocked
		APIAuthorizer: security.Authorized(),
	}
}

/*TrafficOpsAPI The following REST APIs are used by the Traffic Portal UI along with several Traffic Control backend component and services.

This documentation is fully compliant with the Swagger 2.0 specification */
type TrafficOpsAPI struct {
	spec            *loads.Document
	context         *middleware.Context
	handlers        map[string]map[string]http.Handler
	formats         strfmt.Registry
	defaultConsumes string
	defaultProduces string
	Middleware      func(middleware.Builder) http.Handler

	// BasicAuthenticator generates a runtime.Authenticator from the supplied basic auth function.
	// It has a default implemention in the security package, however you can replace it for your particular usage.
	BasicAuthenticator func(security.UserPassAuthentication) runtime.Authenticator
	// APIKeyAuthenticator generates a runtime.Authenticator from the supplied token auth function.
	// It has a default implemention in the security package, however you can replace it for your particular usage.
	APIKeyAuthenticator func(string, string, security.TokenAuthentication) runtime.Authenticator
	// BearerAuthenticator generates a runtime.Authenticator from the supplied bearer token auth function.
	// It has a default implemention in the security package, however you can replace it for your particular usage.
	BearerAuthenticator func(string, security.ScopedTokenAuthentication) runtime.Authenticator

	// JSONConsumer registers a consumer for a "application/json" mime type
	JSONConsumer runtime.Consumer

	// JSONProducer registers a producer for a "application/json" mime type
	JSONProducer runtime.Producer

	// CookieAuth registers a function that takes a token and returns a principal
	// it performs authentication based on an api key cookie provided in the header
	CookieAuth func(string) (interface{}, error)

	// APIAuthorizer provides access control (ACL/RBAC/ABAC) by providing access to the request and authenticated principal
	APIAuthorizer runtime.Authorizer

	// AsnDeleteASNHandler sets the operation handler for the delete a s n operation
	AsnDeleteASNHandler asn.DeleteASNHandler
	// CdnDeleteCDNHandler sets the operation handler for the delete c d n operation
	CdnDeleteCDNHandler cdn.DeleteCDNHandler
	// DivisionDeleteDivisionHandler sets the operation handler for the delete division operation
	DivisionDeleteDivisionHandler division.DeleteDivisionHandler
	// RegionDeleteRegionHandler sets the operation handler for the delete region operation
	RegionDeleteRegionHandler region.DeleteRegionHandler
	// StatusDeleteStatusHandler sets the operation handler for the delete status operation
	StatusDeleteStatusHandler status.DeleteStatusHandler
	// AsnGetASNByIDHandler sets the operation handler for the get a s n by Id operation
	AsnGetASNByIDHandler asn.GetASNByIDHandler
	// AsnGetASNsHandler sets the operation handler for the get a s ns operation
	AsnGetASNsHandler asn.GetASNsHandler
	// CdnGetCDNByIDHandler sets the operation handler for the get c d n by Id operation
	CdnGetCDNByIDHandler cdn.GetCDNByIDHandler
	// CdnGetCDNsHandler sets the operation handler for the get c d ns operation
	CdnGetCDNsHandler cdn.GetCDNsHandler
	// DivisionGetDivisionByIDHandler sets the operation handler for the get division by Id operation
	DivisionGetDivisionByIDHandler division.GetDivisionByIDHandler
	// DivisionGetDivisionsHandler sets the operation handler for the get divisions operation
	DivisionGetDivisionsHandler division.GetDivisionsHandler
	// RegionGetRegionByIDHandler sets the operation handler for the get region by Id operation
	RegionGetRegionByIDHandler region.GetRegionByIDHandler
	// RegionGetRegionsHandler sets the operation handler for the get regions operation
	RegionGetRegionsHandler region.GetRegionsHandler
	// StatusGetStatusByIDHandler sets the operation handler for the get status by Id operation
	StatusGetStatusByIDHandler status.GetStatusByIDHandler
	// StatusGetStatusesHandler sets the operation handler for the get statuses operation
	StatusGetStatusesHandler status.GetStatusesHandler
	// AsnPostASNHandler sets the operation handler for the post a s n operation
	AsnPostASNHandler asn.PostASNHandler
	// CdnPostCDNHandler sets the operation handler for the post c d n operation
	CdnPostCDNHandler cdn.PostCDNHandler
	// DivisionPostDivisionHandler sets the operation handler for the post division operation
	DivisionPostDivisionHandler division.PostDivisionHandler
	// RegionPostRegionHandler sets the operation handler for the post region operation
	RegionPostRegionHandler region.PostRegionHandler
	// StatusPostStatusHandler sets the operation handler for the post status operation
	StatusPostStatusHandler status.PostStatusHandler
	// AsnPutASNHandler sets the operation handler for the put a s n operation
	AsnPutASNHandler asn.PutASNHandler
	// CdnPutCDNHandler sets the operation handler for the put c d n operation
	CdnPutCDNHandler cdn.PutCDNHandler
	// DivisionPutDivisionHandler sets the operation handler for the put division operation
	DivisionPutDivisionHandler division.PutDivisionHandler
	// RegionPutRegionHandler sets the operation handler for the put region operation
	RegionPutRegionHandler region.PutRegionHandler
	// StatusPutStatusHandler sets the operation handler for the put status operation
	StatusPutStatusHandler status.PutStatusHandler

	// ServeError is called when an error is received, there is a default handler
	// but you can set your own with this
	ServeError func(http.ResponseWriter, *http.Request, error)

	// ServerShutdown is called when the HTTP(S) server is shut down and done
	// handling all active connections and does not accept connections any more
	ServerShutdown func()

	// Custom command line argument groups with their descriptions
	CommandLineOptionsGroups []swag.CommandLineOptionsGroup

	// User defined logger function.
	Logger func(string, ...interface{})
}

// SetDefaultProduces sets the default produces media type
func (o *TrafficOpsAPI) SetDefaultProduces(mediaType string) {
	o.defaultProduces = mediaType
}

// SetDefaultConsumes returns the default consumes media type
func (o *TrafficOpsAPI) SetDefaultConsumes(mediaType string) {
	o.defaultConsumes = mediaType
}

// SetSpec sets a spec that will be served for the clients.
func (o *TrafficOpsAPI) SetSpec(spec *loads.Document) {
	o.spec = spec
}

// DefaultProduces returns the default produces media type
func (o *TrafficOpsAPI) DefaultProduces() string {
	return o.defaultProduces
}

// DefaultConsumes returns the default consumes media type
func (o *TrafficOpsAPI) DefaultConsumes() string {
	return o.defaultConsumes
}

// Formats returns the registered string formats
func (o *TrafficOpsAPI) Formats() strfmt.Registry {
	return o.formats
}

// RegisterFormat registers a custom format validator
func (o *TrafficOpsAPI) RegisterFormat(name string, format strfmt.Format, validator strfmt.Validator) {
	o.formats.Add(name, format, validator)
}

// Validate validates the registrations in the TrafficOpsAPI
func (o *TrafficOpsAPI) Validate() error {
	var unregistered []string

	if o.JSONConsumer == nil {
		unregistered = append(unregistered, "JSONConsumer")
	}

	if o.JSONProducer == nil {
		unregistered = append(unregistered, "JSONProducer")
	}

	if o.CookieAuth == nil {
		unregistered = append(unregistered, "CookieAuth")
	}

	if o.AsnDeleteASNHandler == nil {
		unregistered = append(unregistered, "asn.DeleteASNHandler")
	}

	if o.CdnDeleteCDNHandler == nil {
		unregistered = append(unregistered, "cdn.DeleteCDNHandler")
	}

	if o.DivisionDeleteDivisionHandler == nil {
		unregistered = append(unregistered, "division.DeleteDivisionHandler")
	}

	if o.RegionDeleteRegionHandler == nil {
		unregistered = append(unregistered, "region.DeleteRegionHandler")
	}

	if o.StatusDeleteStatusHandler == nil {
		unregistered = append(unregistered, "status.DeleteStatusHandler")
	}

	if o.AsnGetASNByIDHandler == nil {
		unregistered = append(unregistered, "asn.GetASNByIDHandler")
	}

	if o.AsnGetASNsHandler == nil {
		unregistered = append(unregistered, "asn.GetASNsHandler")
	}

	if o.CdnGetCDNByIDHandler == nil {
		unregistered = append(unregistered, "cdn.GetCDNByIDHandler")
	}

	if o.CdnGetCDNsHandler == nil {
		unregistered = append(unregistered, "cdn.GetCDNsHandler")
	}

	if o.DivisionGetDivisionByIDHandler == nil {
		unregistered = append(unregistered, "division.GetDivisionByIDHandler")
	}

	if o.DivisionGetDivisionsHandler == nil {
		unregistered = append(unregistered, "division.GetDivisionsHandler")
	}

	if o.RegionGetRegionByIDHandler == nil {
		unregistered = append(unregistered, "region.GetRegionByIDHandler")
	}

	if o.RegionGetRegionsHandler == nil {
		unregistered = append(unregistered, "region.GetRegionsHandler")
	}

	if o.StatusGetStatusByIDHandler == nil {
		unregistered = append(unregistered, "status.GetStatusByIDHandler")
	}

	if o.StatusGetStatusesHandler == nil {
		unregistered = append(unregistered, "status.GetStatusesHandler")
	}

	if o.AsnPostASNHandler == nil {
		unregistered = append(unregistered, "asn.PostASNHandler")
	}

	if o.CdnPostCDNHandler == nil {
		unregistered = append(unregistered, "cdn.PostCDNHandler")
	}

	if o.DivisionPostDivisionHandler == nil {
		unregistered = append(unregistered, "division.PostDivisionHandler")
	}

	if o.RegionPostRegionHandler == nil {
		unregistered = append(unregistered, "region.PostRegionHandler")
	}

	if o.StatusPostStatusHandler == nil {
		unregistered = append(unregistered, "status.PostStatusHandler")
	}

	if o.AsnPutASNHandler == nil {
		unregistered = append(unregistered, "asn.PutASNHandler")
	}

	if o.CdnPutCDNHandler == nil {
		unregistered = append(unregistered, "cdn.PutCDNHandler")
	}

	if o.DivisionPutDivisionHandler == nil {
		unregistered = append(unregistered, "division.PutDivisionHandler")
	}

	if o.RegionPutRegionHandler == nil {
		unregistered = append(unregistered, "region.PutRegionHandler")
	}

	if o.StatusPutStatusHandler == nil {
		unregistered = append(unregistered, "status.PutStatusHandler")
	}

	if len(unregistered) > 0 {
		return fmt.Errorf("missing registration: %s", strings.Join(unregistered, ", "))
	}

	return nil
}

// ServeErrorFor gets a error handler for a given operation id
func (o *TrafficOpsAPI) ServeErrorFor(operationID string) func(http.ResponseWriter, *http.Request, error) {
	return o.ServeError
}

// AuthenticatorsFor gets the authenticators for the specified security schemes
func (o *TrafficOpsAPI) AuthenticatorsFor(schemes map[string]spec.SecurityScheme) map[string]runtime.Authenticator {

	result := make(map[string]runtime.Authenticator)
	for name, scheme := range schemes {
		switch name {

		case "Cookie":

			result[name] = o.APIKeyAuthenticator(scheme.Name, scheme.In, o.CookieAuth)

		}
	}
	return result

}

// Authorizer returns the registered authorizer
func (o *TrafficOpsAPI) Authorizer() runtime.Authorizer {

	return o.APIAuthorizer

}

// ConsumersFor gets the consumers for the specified media types
func (o *TrafficOpsAPI) ConsumersFor(mediaTypes []string) map[string]runtime.Consumer {

	result := make(map[string]runtime.Consumer)
	for _, mt := range mediaTypes {
		switch mt {

		case "application/json":
			result["application/json"] = o.JSONConsumer

		}
	}
	return result

}

// ProducersFor gets the producers for the specified media types
func (o *TrafficOpsAPI) ProducersFor(mediaTypes []string) map[string]runtime.Producer {

	result := make(map[string]runtime.Producer)
	for _, mt := range mediaTypes {
		switch mt {

		case "application/json":
			result["application/json"] = o.JSONProducer

		}
	}
	return result

}

// HandlerFor gets a http.Handler for the provided operation method and path
func (o *TrafficOpsAPI) HandlerFor(method, path string) (http.Handler, bool) {
	if o.handlers == nil {
		return nil, false
	}
	um := strings.ToUpper(method)
	if _, ok := o.handlers[um]; !ok {
		return nil, false
	}
	if path == "/" {
		path = ""
	}
	h, ok := o.handlers[um][path]
	return h, ok
}

// Context returns the middleware context for the traffic ops API
func (o *TrafficOpsAPI) Context() *middleware.Context {
	if o.context == nil {
		o.context = middleware.NewRoutableContext(o.spec, o, nil)
	}

	return o.context
}

func (o *TrafficOpsAPI) initHandlerCache() {
	o.Context() // don't care about the result, just that the initialization happened

	if o.handlers == nil {
		o.handlers = make(map[string]map[string]http.Handler)
	}

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/asns/{id}"] = asn.NewDeleteASN(o.context, o.AsnDeleteASNHandler)

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/cdns/{id}"] = cdn.NewDeleteCDN(o.context, o.CdnDeleteCDNHandler)

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/divisions/{id}"] = division.NewDeleteDivision(o.context, o.DivisionDeleteDivisionHandler)

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/regions/{id}"] = region.NewDeleteRegion(o.context, o.RegionDeleteRegionHandler)

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/statuses/{id}"] = status.NewDeleteStatus(o.context, o.StatusDeleteStatusHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/asns/{id}"] = asn.NewGetASNByID(o.context, o.AsnGetASNByIDHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/asns"] = asn.NewGetASNs(o.context, o.AsnGetASNsHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/cdns/{id}"] = cdn.NewGetCDNByID(o.context, o.CdnGetCDNByIDHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/cdns"] = cdn.NewGetCDNs(o.context, o.CdnGetCDNsHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/divisions/{id}"] = division.NewGetDivisionByID(o.context, o.DivisionGetDivisionByIDHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/divisions"] = division.NewGetDivisions(o.context, o.DivisionGetDivisionsHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/regions/{id}"] = region.NewGetRegionByID(o.context, o.RegionGetRegionByIDHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/regions"] = region.NewGetRegions(o.context, o.RegionGetRegionsHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/statuses/{id}"] = status.NewGetStatusByID(o.context, o.StatusGetStatusByIDHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/statuses"] = status.NewGetStatuses(o.context, o.StatusGetStatusesHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/asns"] = asn.NewPostASN(o.context, o.AsnPostASNHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/cdns"] = cdn.NewPostCDN(o.context, o.CdnPostCDNHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/divisions"] = division.NewPostDivision(o.context, o.DivisionPostDivisionHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/regions"] = region.NewPostRegion(o.context, o.RegionPostRegionHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/statuses"] = status.NewPostStatus(o.context, o.StatusPostStatusHandler)

	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/asns/{id}"] = asn.NewPutASN(o.context, o.AsnPutASNHandler)

	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/cdns/{id}"] = cdn.NewPutCDN(o.context, o.CdnPutCDNHandler)

	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/divisions/{id}"] = division.NewPutDivision(o.context, o.DivisionPutDivisionHandler)

	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/regions/{id}"] = region.NewPutRegion(o.context, o.RegionPutRegionHandler)

	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/statuses/{id}"] = status.NewPutStatus(o.context, o.StatusPutStatusHandler)

}

// Serve creates a http handler to serve the API over HTTP
// can be used directly in http.ListenAndServe(":8000", api.Serve(nil))
func (o *TrafficOpsAPI) Serve(builder middleware.Builder) http.Handler {
	o.Init()

	if o.Middleware != nil {
		return o.Middleware(builder)
	}
	return o.context.APIHandler(builder)
}

// Init allows you to just initialize the handler cache, you can then recompose the middelware as you see fit
func (o *TrafficOpsAPI) Init() {
	if len(o.handlers) == 0 {
		o.initHandlerCache()
	}
}
